"use strict";
var AdmZip = require('adm-zip');
var fs = require('fs');
var minimist = require('minimist');
var os = require('os');
var path = require('path');
var opts_1 = require('./opts');
var Opt = require('./');
var config_1 = require('../config');
var binaries_1 = require('../binaries');
var files_1 = require('../files');
var cli_1 = require('../cli');
var logger = new cli_1.Logger('update');
var prog = new cli_1.Program()
    .command('update', 'install or update selected binaries')
    .action(update)
    .addOption(opts_1.Opts[Opt.OUT_DIR])
    .addOption(opts_1.Opts[Opt.IGNORE_SSL])
    .addOption(opts_1.Opts[Opt.PROXY])
    .addOption(opts_1.Opts[Opt.ALTERNATE_CDN])
    .addOption(opts_1.Opts[Opt.STANDALONE])
    .addOption(opts_1.Opts[Opt.CHROME]);
if (os.type() === 'Windows_NT') {
    prog.addOption(opts_1.Opts[Opt.IE]).addOption(opts_1.Opts[Opt.IE32]);
}
prog
    .addOption(opts_1.Opts[Opt.VERSIONS_STANDALONE])
    .addOption(opts_1.Opts[Opt.VERSIONS_CHROME]);
if (os.type() === 'Windows_NT') {
    prog.addOption(opts_1.Opts[Opt.VERSIONS_IE]);
}
exports.program = prog;
// stand alone runner
var argv = minimist(process.argv.slice(2), prog.getMinimistOptions());
if (argv._[0] === 'update-run') {
    prog.run(JSON.parse(JSON.stringify(argv)));
}
else if (argv._[0] === 'update-help') {
    prog.printHelp();
}
/**
 * Parses the options and downloads binaries if they do not exist.
 * @param options
 */
function update(options) {
    var standalone = options[Opt.STANDALONE].getBoolean();
    var chrome = options[Opt.CHROME].getBoolean();
    var ie = false;
    var ie32 = false;
    if (options[Opt.IE]) {
        ie = options[Opt.IE].getBoolean();
    }
    if (options[Opt.IE32]) {
        ie32 = options[Opt.IE32].getBoolean();
    }
    var outputDir = config_1.Config.getSeleniumDir();
    if (options[Opt.OUT_DIR].getString()) {
        if (path.isAbsolute(options[Opt.OUT_DIR].getString())) {
            outputDir = options[Opt.OUT_DIR].getString();
        }
        else {
            outputDir = path.resolve(config_1.Config.getBaseDir(), options[Opt.OUT_DIR].getString());
        }
        files_1.FileManager.makeOutputDirectory(outputDir);
    }
    var ignoreSSL = options[Opt.IGNORE_SSL].getBoolean();
    var proxy = options[Opt.PROXY].getString();
    // setup versions for binaries
    var binaries = files_1.FileManager.setupBinaries();
    binaries[binaries_1.StandAlone.id].versionCustom = options[Opt.VERSIONS_STANDALONE].getString();
    binaries[binaries_1.ChromeDriver.id].versionCustom = options[Opt.VERSIONS_CHROME].getString();
    if (options[Opt.VERSIONS_IE]) {
        binaries[binaries_1.IEDriver.id].versionCustom = options[Opt.VERSIONS_IE].getString();
    }
    // if the file has not been completely downloaded, download it
    // else if the file has already been downloaded, unzip the file, rename it, and give it permissions
    if (standalone) {
        var binary_1 = binaries[binaries_1.StandAlone.id];
        files_1.FileManager.toDownload(binary_1, outputDir).then(function (value) {
            if (value) {
                files_1.Downloader.downloadBinary(binary_1, outputDir);
            }
            else {
                logger.info(binary_1.name + ': file exists ' + path.resolve(outputDir, binary_1.filename(os.type(), os.arch())));
                logger.info(binary_1.name + ': v' + binary_1.versionCustom + ' up to date');
            }
        });
    }
    if (chrome) {
        var binary = binaries[binaries_1.ChromeDriver.id];
        updateBinary(binary, outputDir, proxy, ignoreSSL);
    }
    if (ie) {
        var binary = binaries[binaries_1.IEDriver.id];
        binary.arch = os.arch(); // Win32 or x64
        updateBinary(binary, outputDir, proxy, ignoreSSL);
    }
    if (ie32) {
        var binary = binaries[binaries_1.IEDriver.id];
        binary.arch = 'Win32';
        updateBinary(binary, outputDir, proxy, ignoreSSL);
    }
}
function updateBinary(binary, outputDir, proxy, ignoreSSL) {
    files_1.FileManager.toDownload(binary, outputDir).then(function (value) {
        if (value) {
            files_1.Downloader.downloadBinary(binary, outputDir, proxy, ignoreSSL, unzip);
        }
        else {
            logger.info(binary.name + ': file exists ' + path.resolve(outputDir, binary.filename(os.type(), os.arch())));
            var fileName = binary.filename(os.type(), os.arch());
            unzip(binary, outputDir, fileName);
            logger.info(binary.name + ': v' + binary.versionCustom + ' up to date');
        }
    });
}
function unzip(binary, outputDir, fileName) {
    // remove the previously saved file and unzip it
    var osType = os.type();
    var mv = path.join(outputDir, binary.executableFilename(osType));
    try {
        fs.unlinkSync(mv);
    }
    catch (err) { }
    // unzip the file
    logger.info(binary.name + ': unzipping ' + fileName);
    var zip = new AdmZip(path.resolve(outputDir, fileName));
    zip.extractAllTo(outputDir, true);
    // rename
    fs.renameSync(path.join(outputDir, binary.name + binary.executableSuffix(osType)), mv);
    // set permissions
    if (osType !== 'Windows_NT') {
        logger.info(binary.name + ': setting permissions to 0755 for ' + mv);
        fs.chmodSync(mv, '0755');
    }
}
